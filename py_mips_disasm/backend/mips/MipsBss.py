#!/usr/bin/python3

from __future__ import annotations

from ..common.Utils import *
from ..common.GlobalConfig import GlobalConfig
from ..common.Context import Context, ContextSymbol

from .MipsSection import Section


class Bss(Section):
    def __init__(self, bssVramStart: int, bssVramEnd: int, filename: str, context: Context):
        super().__init__(bytearray(), filename, context)

        self.bssVramStart: int = bssVramStart
        self.bssVramEnd: int = bssVramEnd

        self.vRamStart = bssVramStart


    def setVRamStart(self, vRamStart: int):
        super().setVRamStart(vRamStart)

        diff = self.bssVramEnd - self.bssVramStart
        self.bssVramStart = vRamStart
        self.bssVramEnd = vRamStart + diff

    def analyze(self):
        # Check if the very start of the file has a bss variable and create it if it doesn't exist yet
        if self.context.getSymbol(self.bssVramStart, False) is None:
            contextSym = ContextSymbol(self.bssVramStart, "B_" + toHex(self.bssVramStart, 8)[2:])
            contextSym.isDefined = True
            contextSym.isBss = True
            contextSym.isAutogenerated = True
            if self.newStuffSuffix:
                contextSym.name += f"_{self.newStuffSuffix}"
            self.context.symbols[self.bssVramStart] = contextSym

        # If something that could be a pointer found in data happens to be in the middle of this bss file's addresses space
        # Then consider it a new bss variable
        for ptr in sorted(self.context.newPointersInData):
            if ptr < self.bssVramStart:
                continue
            if ptr >= self.bssVramEnd:
                break

            contextSym = self.context.getGenericSymbol(ptr)
            if contextSym is None:
                contVar = ContextSymbol(ptr, f"B_{ptr:08X}")
                contVar.isDefined = True
                contVar.isBss = True
                contVar.isAutogenerated = True

                self.context.symbols[ptr] = contVar
            else:
                if contextSym.isAutogenerated:
                    contextSym.name = f"B_{ptr:08X}"

        # Mark every known symbol that happens to be in this address space as defined
        for vram in self.context.symbols.irange(minimum=self.bssVramStart, maximum=self.bssVramEnd, inclusive=(True, False)):
            contextSym = self.context.symbols[vram]
            contextSym.isDefined = True
            contextSym.isBss = True
            if contextSym.isAutogenerated:
                contextSym.name = f"B_{vram:08X}"


    def disassembleToFile(self, f: TextIO):
        f.write(".include \"macro.inc\"\n")
        f.write("\n")
        f.write("# assembler directives\n")
        f.write(".set noat      # allow manual use of $at\n")
        f.write(".set noreorder # don't insert nops after branches\n")
        f.write(".set gp=64     # allow use of 64-bit general purpose registers\n")
        f.write("\n")
        f.write(".section .bss\n")
        f.write("\n")
        f.write(".balign 16\n")

        # Needs to move this to a list because the algorithm requires to check the size of a bss variable based on the next bss variable' vram
        # TODO: sorted() may not be required here anymore because of SortedDict. Test if removing it doesn't break anything
        sortedSymbols = sorted(self.context.symbols.irange(minimum=self.bssVramStart, maximum=self.bssVramEnd, inclusive=(True, False)))
        i = 0
        while i < len(sortedSymbols):
            symbolVram = sortedSymbols[i]
            symbol = self.context.symbols[symbolVram]

            self.context.symbols[symbolVram].isDefined = True

            offset = symbolVram - self.bssVramStart
            inFileOffset = self.offset + offset

            offsetHex = toHex(inFileOffset + self.commentOffset, 6)[2:]
            vramHex = toHex(symbolVram, 8)[2:]

            # Calculate the space of the bss variable
            space = self.bssVramEnd - symbolVram
            if i + 1 < len(sortedSymbols):
                if sortedSymbols[i+1] <= self.bssVramEnd:
                    space = sortedSymbols[i+1] - symbolVram

            label = f"\nglabel {symbol.name}\n"

            # try to get the symbol name from the offset of the file (possibly from a .o elf file)
            if inFileOffset in self.symbolNameOffsets:
                possibleSymbolName = self.symbolNameOffsets[inFileOffset]
                if possibleSymbolName is not None:
                    if possibleSymbolName.startswith("."):
                        label = f"\n/* static variable */\n{possibleSymbolName}\n"
                    else:
                        label = f"\nglabel {possibleSymbolName}\n"

            f.write(f"{label}/* {offsetHex} {vramHex} */  .space  {toHex(space, 2)}\n")
            i += 1

    def saveToFile(self, filepath: str):
        super().saveToFile(filepath + ".bss")

        if filepath == "-":
            self.disassembleToFile(sys.stdout)
        else:
            with open(filepath + ".bss.s", "w") as f:
                self.disassembleToFile(f)
